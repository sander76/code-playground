from Crypto.Hash import SHA3_256

################ HASHING

# converting an input value into a fixed size, reproducable,
# but irreversible output value (aka hash, message digest).
#
# use case:
# - integrity checking.
# - password storage
# - document identity (commit hashes)
# - pseudo random number generator (where the input value is the seed)


h_obj = SHA3_256.new()
h_obj.update(b"some data")
print(h_obj.hexdigest())

print(SHA3_256.new(b"some data").hexdigest())

assert h_obj.hexdigest() == SHA3_256.new(b"some data").hexdigest()  # identical.


################# MAC / HMAC

# MAC (Message Authentication Codes) and Key derivation
# MAC's are also known as "keyed hash functions"

from Crypto.Hash import HMAC

my_hmac = HMAC.new(b"my key", b"my value", digestmod=SHA3_256)
print(my_hmac.hexdigest())

## usage scenario: message authentication checking
# sender and receiver have a pre-shared key: "my key"
# Sender sends a message and an hmac generated by the message and the "my key"
# receiver generates its own hmac using the received message and the pre-shared key.
# hmacs must be identical.

## usage scenario: authenticated-encryption.
#
from Crypto.Cipher import AES

# SENDER
org_message = "my plaintext message."
key_from_password = SHA3_256.new(b"my shared password")

# encrypt the org_message
cipher = AES.new(key_from_password.digest(), mode=AES.MODE_CTR)
encrypted_message = cipher.encrypt(org_message.encode())

# create an hmac using the key_from_password and the ORG message.
hmac_code = HMAC.new(key=key_from_password.digest(), msg=org_message.encode())

message_to_send = encrypted_message + hmac_code.digest()

# RECEIVER
received_message = message_to_send
key_from_password = SHA3_256.new(b"my shared password")
cipher = AES.new(key=key_from_password.digest(), mode=AES.MODE_CTR)

decrypted = cipher.decrypt(
    received_message
)  # this contains the plaintext message + the generated hmac.
org_message, hmac = decrypted[:100], decrypted[100:]  # pseudo slice.

# We now have the original message back from which we can calculate an hmac (using the already
# available "my shared password")
# this generated hmac must be identical to the hmac which was included in the encrypted message.

## KDF (key derivation function) transforms a variable length password to fixed-length key.
# You could use AES256 hashing for this, but is vulnerable to dictionary attacks.
# You could also use hmac HMAC(salt,msg,SHA256). salt is a random value. But this is also less
# secure than dedicated kdf's. like Bcrypt, Scrypt or Argon2.

# KDF needs to be expensive (on cpu and mem) to discourage brute forcing.

import argon2

ph = argon2.PasswordHasher()


def login(storage: dict, user: str, password: str):
    """Login.

    Args:
        storage: A user:hash mapping
    """
    hash = storage[user]
    try:
        ph.verify(hash, password)
    except argon2.exceptions.VerifyMismatchError:
        print(f"wrong password provided for {user=!r}")
        return

    if ph.check_needs_rehash(hash):
        print("re-hashing")
        storage[user] = ph.hash(password)
    print(f"user {user} logged in.")


def create_user(storage, user, password):
    storage[user] = ph.hash(password)
    print(
        f"created user {user} with password {password} stored as hash {storage[user]}"
    )


storage = {}

create_user(storage, "sander", "mypass")

login(storage, "sander", "mypass")
login(storage, "sander", "invalid pass")

################# SECURE RANDOM GENERATORS

# PRNG : Pseudo Random Number Generator: insecure
# CSPRNG: CS ? PRNG: secure.

# import random
# creates insecure randomness

# import secrets
# import os.urandom()
# creates secure randomness based on entropy (unpredictable randomness) collected by your system.
